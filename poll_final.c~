// final polling 

// #include <cstdlib>
#include <unistd.h>
#include <netdb.h>
#include <poll.h>
#include <stdio.h>
#include <string.h>
#include <sys/poll.h>
#include <stdlib.h>
#include <sys/select.h>
#include <sys/socket.h>

int get_listener() {

    struct addrinfo hints, *ai, *p;

    int listener;
    int yes=1;
    int rv;

    memset(&hints, 0, sizeof hints);
    hints.ai_socktype = SOCK_STREAM;
    hints.ai_flags = AI_PASSIVE;
    hints.ai_family = AF_INET;

    if ((getaddrinfo(NULL, "3001", &hints, &ai)) != 0) {
        perror("error occured in initializing struct");
    }

    for(p = ai; p != NULL; p = p->ai_next) {
        listener = socket(p->ai_family, p->ai_socktype,
                          p->ai_protocol);
        if (listener < 0) {
            continue;
        }

        // Lose the pesky "address already in use" error message
        setsockopt(listener, SOL_SOCKET, SO_REUSEADDR, &yes,
                   sizeof(int));

        if (bind(listener, p->ai_addr, p->ai_addrlen) < 0) {
            // close(listener);
            continue;
        }

        break;
    }

    // If we got here, it means we didn't get bound
    if (p == NULL) {
        return -1;
    }

    freeaddrinfo(ai); // All done with this

    // Listen
    if (listen(listener, 10) == -1) {
        return -1;
    }

    return listener;
}

void del_from_pfds(struct pollfd *pfds, int *pfd_i, int *fd_count) {
    // Copy the one from the end over this one
    pfds[*pfd_i] = pfds[*fd_count-1];

    (*fd_count)--; 
}

void handle_client_data(int listener, int *fd_count,
                        struct pollfd *pfds, int *pfd_i)
{
    char buf[256];    // Buffer for client data

    int nbytes = recv(pfds[*pfd_i].fd, buf, sizeof buf, 0);

    int sender_fd = pfds[*pfd_i].fd;

    if (nbytes <= 0) { // Got error or connection closed by client
        if (nbytes == 0) {
            // Connection closed
            printf("pollserver: socket %d hung up\n", sender_fd);
        } else {
            perror("recv");
        }

        close(pfds[*pfd_i].fd); // Bye!

        del_from_pfds(pfds, pfd_i, fd_count);

        // reexamine the slot we just deleted
        (*pfd_i)--;

    } else { // We got some good data from a client
        printf("pollserver: recv from fd %d: %.*s", sender_fd,
               nbytes, buf);
        // Send to everyone!
        for(int j = 0; j < *fd_count; j++) {
            int dest_fd = pfds[j].fd;

            // Except the listener and ourselves
            if (dest_fd != listener && dest_fd != sender_fd) {
                if (send(dest_fd, buf, nbytes, 0) == -1) {
                    perror("send");
                }
            }
        }
    }
}

void add_to_pfds(int newfd, struct pollfd **pfds, int *fd_count, int *fd_size) {
    // TODO;realloc if size is full

    printf("adding to array");

    if (*fd_size == *fd_count) {
        *fd_size *= 2;
        *pfds = realloc(*pfds, sizeof(**pfds)*(*fd_size)); 
    }

    (*pfds)[*fd_count].fd = newfd;
    (*pfds)[*fd_count].events = POLLIN;
    (*pfds)[*fd_count].revents = 0;
    (*fd_count)++;

}

void accept_connection(struct pollfd **pfds, int *fd_count, int *fd_size, int listener) {

    struct sockaddr_storage storage;
    socklen_t socklen;

    int a = accept(listener, (struct sockaddr *)&storage, &socklen);
    if (a == -1){
        perror("accept");
        // return;
    }

    // add to pfds
    add_to_pfds(a, pfds, fd_count, fd_size);

    char *smsg = "Thank you for connecting!";
    // snprintf(smsg,40,"thank you for connecting; %d;xyz \n", a);
    int msg = send(a, smsg, 50, 0);
    if (msg == -1) {
        perror("send");
    }

}

void process_connection(struct pollfd **pfds, int *fd_size, int *fd_count, int listener) {
    for (int i = 0; i < *fd_count; i++) {
        // printf("printing the value that the pfds is containing : %d", pfds[i].revents);
        if ((*pfds)[i].revents & (POLLIN | POLLHUP))  {
            if ((*pfds)[i].fd == listener) {
                accept_connection(pfds, fd_count, fd_size, listener);
            }
            else {
                handle_client_data(listener, fd_count, *pfds, &i);
            }
        }
    }
}

int main () {

    printf("polling is now starting \n");

    int fd_size = 5;
    int fd_count = 0;

    struct pollfd *pfds = malloc(fd_size*2);
    // struct pollfd pfds[fd_size];

    int listener = get_listener();

    pfds[0].fd = listener;
    pfds[0].events = POLLIN;
    fd_count = 1;

    for (;;) {
        int pollres = poll(pfds, fd_count, -1);
        if (pollres == -1) {
            perror("polling");
        }
        process_connection(&pfds, &fd_size, &fd_count, listener);
    }

    free(pfds);

    return 0;
}
